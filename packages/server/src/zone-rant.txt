I'm going to approach your post as an Angular (frontend) developer. As I've noted above, Zone.js is far more useful outside of Angular than in, but it's clear you are coming at it from that angle, and there's plenty to discuss.

Before I get into a detailed response, I'll note that I've heard all this before, many times. What I haven't heard is folks with a deep understanding of Zone.js and the real down-to-the-metal performance impacts of Angular as a framework weigh in too often. I hope my two cents is useful as someone who has built heavily performance intensive apps; I have built several broadcast-quality realtime audio/video processing apps for the broadcast industry built with Angular. I'm not saying that any of what you've said is necessarily incorrect, just that it feels misguided to me, and doesn't fit my experience of the technology stack based on the projects I've worked on.

> It's complex

This word is doing a lot here. Let me address it this way: As an Angular app developer, when it comes to Zone.js and how its used in Angular, I only care about the following things:
1. I care when Zone.js is not performant 
When this happens, one should escape from Zone.js using NgZone#runOutsideAngular(). That is what it's for. This is relevant is when you are doing highly performance sensitive work such as processing audio frames, updating meters, rendering canvases, or other requestAnimationFrame style use cases. Escape from the zone, and return using `NgZone#run()`. Don't ignore the tools the Angular team has given you. What I've found is that in these scenarios the real problem is Angular's change detection entirely. When you are solving those problems, you sometimes have to omit using Angular's model binding system entirely to accomplish the goal. In that context, using Zone.js to handle change detection for a settings dialog is not the bottleneck.

2. I care when Zone.js impacts debuggability 
Zone.js definitely impacts debuggability. Stack traces are difficult. But not unworkably so. Throwing the baby out with the bathwater for this point seems woefully short sighted.

3. I care when my code escapes from its Zone
When Zone is not adequately handling the available async-capable APIs, this happens. More on this below.

> adds weight

For change detection, you are correct. But this isn't going to be relevant when you are doing the typical Angular app- it will be relevant when you are doing requestAnimationFrame(), tight timers, or other code which frequently waits for promises to complete. When this happens, do the above: Escape from the zone, and return to do change detection. Don't rearchitect your entire application simply to serve your 1% use case- most of your app is forms over data, and Zone.js' change detection strategy works for that. The escape is there for the 1% where it doesn't.

> requires to be maintained.

Maintained as new async web APIs are added yes. Not maintained by the app developer of course, but maintained by the Zone.js developers themselves. So then the question becomes, how often are new async opportunities added to Web APIs? Well, you can look at the commits in https://github.com/angular/angular/commits/master/packages/zone.js where Jia Li has been maintaining Zone.js, and really there hasn't been much needed to keep it working (with the async/await-pocalypse the main exception). Seems like more work has gone into Bazel and testing which was going to be done regardless of the merits of Zone.js as a library.

> It's a monkey patching. So by definition not a forward-looking idea. 

Monkey patching is adding new user-land functionality to existing interfaces. Zone.js doesn't do this, it _instruments_ those interfaces. I would agree if Zone added new methods to String, or modified the parameters that Regexp took. But this isn't the case.

> It might potentially make the patched functions work differently in comparison with native/original behavior 

This is possible, and I think we'd all like to see Zones as a language primitive where it has no chance of this happening, but the runtime timing model of Javascript is such that there ultimately are only 3 critical concepts: The macrotask, the microtask, and the turn. This is how every Javascript runtime you've ever used is constructed, and Zone.js only needs to layer on instrumentation for recording when these concepts are scheduled and when they complete. Thus, Zone.js need only express the scheduling and macro/micro task behavior of the API it is patching. It's complex when you look under the hood, but the runtime semantics of setTimeout don't change with every newly published ES release, so the chance of breaking semantics is rather low for a given API once the patching is stable. Would love to hear about concrete cases where you've seen Zone.js modify runtime semantics (other than stack traces ðŸ˜…) in a way that impacted your business logic.

> and also might affect the performance. 

Yes, but as I've noted in previous posts and have hinted at above, it is easy to equate the cost of Angular's change detection cycle with Zone.js itself. Remember, all Zone.js does is let Angular know when your callback is done executing, it is the actual change detection process which is expensive. 
If you don't believe me that Zone.js isn't dramatically impacting your frontend performance, just try this: Take your app that uses reactive stores with onPush and add Zone.js back in in your `main.ts`, just as an experiment:

```typescript
import 'zone.js';
import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';

import { AppModule } from './app/app.module';
import { environment } from './environments/environment';

let zone = Zone.current.fork();

zone.run(() => {
    platformBrowserDynamic().bootstrapModule(AppModule)
    .catch(err => console.error(err));
})
```

Technically speaking, running Angular in a Zone isn't even required for Zone to be active. Just loading it will cause all the patches to be in place. Nonetheless, I'm quite certain that almost all of the perceived performance issues you are referring to will be gone, because the expensive part is change detection, not Zone.js itself. And this is why disabling change detection with NgZone#runOutsideAngular is so useful for managing performance overhead, not because it eliminates the overhead of Zone.js, but because it eliminates the overhead of extra change detection cycles.

> Async/await is/was the first blocker, there might be more in the future.

I'll grant you that it is possible a future feature could cause a problem, but that's not a reason to ignore the use cases that only Zone.js or a similar context tracing / observability solution enables.

> There is no such thing as an interface put on top of implementation. So if you started using it from day one there won't be a simple way to replace the change detection by changing the interface implementation without a need to rethink and rewrite a huge part of the code base. No interface and so no simple/static/type-safe way to detect all the places where the change detection is being triggered. So you got Angular built on DI and other enterprise-grade fancy ideas but here you left with just that "implicit magic".

This is only a major concern if you are thinking that you will need to remove Zone.js for either (A) performance reasons (see above) or (B) compatibility problems causing zone escape, of which (other than bugs found and fixed in Zone.js along the way) there has really only been one existential problem: async/await. In the case of bugs with Zone.js that have existed before which may have allowed your callbacks to modify Angular's model state without a corresponding change detection cycle, you always had the option of re-entering the zone in that specific circumstance to rectify the issue. So far it has only been async/await which has not had an easy straightforward fix.

> It's enabled by default and so most of the devs likely just go with it without a doubt.

It's the default because most apps are forms over data. The "just work" part of it has always been Angular's promise, and Zone.js' use in Angular 2+ was just the next obvious step. If you remember back in the Angular.js days, you might remember that the built-in HTTP service would trigger `$digest` automatically after your callback handled the HTTP response. Zone.js was just the next evolution of this, providing an "it just works" experience in the apps which Angular was originally designed to create.

> It hides how things work from those who just go with defaults.

This is what a framework is for. Angular also hides how efficient virtual DOM diffing works, and how the dependency injection container is properly constructed from your disparate sets of DI providers. That doesn't make it an inherently bad thing.

> Not saying that Angular itself is a bad thing and of course not saying that zone.js is completely useless. But if I would be forced to start a project on Angular, these days I'd go with a reactive store, for example using @ngrx/store + @ngrx/component-store, onPush change detection, and fully disabled zone.js thing.

Do your thing, but I personally am not a fan of using reactive stores or ngrx. Service with a Subject is more than enough when used properly, and is a more composable model than dictating a central data store for the entire application. The complexity introduced by reactive store models is far from free and time travel debugging isn't enough for me to overhaul the entire application architecture for.